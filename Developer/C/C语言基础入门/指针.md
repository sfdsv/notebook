# 指针

### 什么是指针？

**指针也就是内存地址，指针变量是用来存放内存地址的变量**。就像其他变量或常量一样，必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式：

```c
type *var_name
```

`type`是指针的基类型，必须是一个有效的C数据类型；

`var_name`是指针变量的名称；

### 如何使用指针？

* 定义一个指针变量
* 把变量地址赋值给指针
* 访问指针变量中可用地址的值*

```c
#include <stdio.h>

int main ()
{
    int var = 20;   /* 实际变量的声明 此时的 VAR 这个变量是存在某个地址的，地址对应某个内存单元，该单元中存储了数据20 */
    int *ip;         /* 指针变量的声明 定义了一个指针 即一个内存单元的地址变量 */

    ip = &var;      /* 在指针变量中存储 var 的地址 就是将地址值赋值给指针这个变量*/

    /* 在指针变量中存储的地址 利用&符号直接输出了var所存储的数据的内存单元的地址*/
    printf("Address of var variable: %p\n", &var );
    
    /* 在指针变量中存储的地址 ip代表的是这个赋值到的地址的值 所以输出的是地址值 */
    printf("Address stored in ip variable: %p\n", ip );
    
    /* 使用指针访问值 *ip代表的是定义到这个内存单元之后，内存单元中所存储的数据的值也就是将20赋值给var中20这个值 */
    printf("Value of *ip variable: %d\n", *ip );

    return 0;
}
```

```
var 变量的地址: 0x7ffeeef168d8
ip 变量存储的地址: 0x7ffeeef168d8
*ip 变量的值: 20
```

#### 访问那个地址上的变量*

* *是一个单目运算符,用来访问指针的值所表示的地址上的变量
* 可以做右值也可以做左值
  * `int k = *p;`（`*p`作为一个整体，就可以看做一个int）
  * `*p=k+1;`

### C中的NULL指针

赋值为NULL值的指针被称为空指针。NULL指针是一个定义在标准库中的值为零的常量。

所有指针在创建时都要初始化，如果不知道他指向什么就将 0 赋值给他。**必须初始化指针，没有被初始化的指针被称为失控指针(野指针）**。

检查一个空指针，可以使用if语句：

```c
if(ptr)     /* 如果 p 非空，则完成 */
if(!ptr)    /* 如果 p 为空，则完成 */
```

### 函数参数表里的数组

* 传入函数参数表里的数组实际上是一个指针（数组的首地址）
  * `sizeof(a)==sizeof(int*)`
  * 但是可以用数组的运算符[]进行运算

#### 数组参数

以下四种函数原型是等价的：

* `int sum(int *ar,int n);`
* `int sum(int *,int);`
* `int sum(int ar[],int n);`
* `int sum(int [],int);`

不是说它们的类型是等价的，而是它们在参数表中出现是等价的，作为函数原型，它们是等价的。

### 数组变量是特殊的指针

* 数组变量本身表达地址，所以
  * `int a[10];int *p=a; //无需用&取地址`
  * 但是数组的单元表达的是变量，需要用&取地址 
  *  `a==&a[0]`
* `[]`运算符可以对数组做，也可以对指针做：
  * `p[0] <==> a[0]`

* *运算符可以对指针做，也可以对数组做：
  * `*a=25;`
* 数组变量是`const`的指针，所以不能被赋值
  * `int a[] <==> int * const a=...`

```c
int main(void) {
    int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int b[] =a ; × //int b[] --> int * const b;const说明b是一个常数，不能被改变，初始化后就不能代表别的数组，是一个常量指针。
    int *q = a; √
}
```

## 指针与`const`

指针可以是`const`，指针所指向的变量也可以是`const`。

### 指针是`const`

* 表示一旦得到了某个变量的地址，不能再指向其它变量

```c
#include <stdio.h>

int main(void) {
    int i;

    int *const q = &i;//q是const
    *q = 26;//OK
    q++;//ERROR
}
```

### 所指是`const`

* 表示不能通过这个指针取修改那个变量（并不能使得那个变量成为`const`）

```c
#include <stdio.h>

int main(void) {
    int i;
    int j;

    const int *p = &i;
    *p = 26;//ERROR (*p)是const
    i = 26;//OK
    p = &j;//OK
}
```

```c
int i;

const int* p1 = &i;//*p不能变
int const* p2 = &i;

int *const p3 = &i;//p不能变

//判断哪个被const了的标志是const在*的前面还是后面
```

### 转换

* 总是可以把一个非`const`的值转换成`const`的

```c
void f(const int * x);
int a=15;
f(&a);//ok
const int b=a;
f(&b);//ok
b=a+1;//Error
```

* 当要传递的参数的类型比地址大的时候，这是常用的手段。
  * 既能用比较少的字节数传递值给参数
  * 又能避免函数对外面的变量的修改

### `const`数组

* `const int a[]={1,2,3,4,5,6,};`
* 数组变量已经是`const`的指针了，这里的`const`表明数组的每个单元都是`const int`
* 所以必须通过初始化进行赋值

### 保护数组值

* 因为把数组传入函数时传递的是地址，所以函数内部可以修改数组的值
* 为了保护数组不被函数破坏，可以设置参数为`const`
  * `int sum(const int a[],int length);`

## 指针运算

