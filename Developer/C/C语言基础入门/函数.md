# 函数

## 函数声明

编译器不检查函数参数的名称，只检查参数的类型和数量。

## 函数调用

* 如果函数有参数，调用函数时必须传递给它数量、类型正确的值
* 可以传递给函数的值是表达式的结果，这包括
  * 字面量
  * 变量
  * 函数的返回值
  * 计算的结果

```c
int a,b,c;
a=5;
b=6;
c=max(10,12);
c=max(a,b);
c=max(c,23);
c=max(max(23,45),a);
c=max(23+45,b);
```

### 类型不匹配？

* 调用函数时给的值与参数的类型不匹配是C语言传统上最大的漏洞
* 编译器总是悄悄替你把类型转换好，但是这很可能不是你所期望的

```c
void cheer(int i){
    printf("cheer %d\n",i);
}

int main() {
    cheer(2.4);
    return 0;
}

//output:cheer 2
```

## 传值

* 每个函数有自己的变量空间，参数也位于这个独立的空间中，和其它函数没有关系
* C语言在调用函数时，永远只能传值给函数
* 过去，对于函数参数表中的参数，叫做“形式参数”，调用函数时给的值，叫做“实际参数”

### 本地变量（局部变量）

* 函数的每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量
* 定义在函数内部的变量就是本地变量
* 参数也是本地变量
* 本地变量是定义在块内的，程序运行进入中广核块之前，其中的变量不存在，离开这个块，其中的变量就消失了
  * 它可以是定义在函数的块内
  * 也可以定义在语句的块内
  * 甚至可以随便拉一对大括号来定义变量

* 块外面定义的变量在里面仍然有效
* 块里面定义了和外面同名的变量则掩盖了外面的
* 不能在一个块内定义同名的变量
* **本地变量不会被默认初始化**
* 参数在进入函数的时候被初始化了

#### 变量的生存期和作用域

* 生存期：什么时候这个变量开始出现了，到什么时候它消亡了
* 作用域：在（代码的）什么范围内可以访问这变量（这个变量可以起作用）
* 对于本地变量，这两个问题的答案是统一的：大括号内——块

## 函数里的函数？

* C语言不允许函数嵌套定义
* 可以放一个函数的声明，但不能放另一个函数的body
