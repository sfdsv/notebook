**三次握手**

第一次握手：客户端发送syn包(seq=x)到服务器，并进入SYN_SEND(发送)状态，等待服务器确认；

第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（seq=y），即SYN+ACK包，此时服务器进入SYN_RECV（接收）状态；

第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED（已建立）状态，完成三次握手。

说明：

1）SYN和ACK是标志位（0/1）（ACK=1表明ack有效），seq是序列号，ack是确认号。
2）给对方的确认方式就是把对方传来的seq+1并赋给ack。


**四次挥手**

第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了
(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。

第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1。

第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。

第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。

说明：

1）SYN攻击 用众多伪造ip地址向服务器发送SYN=1（请求连接），让服务器处于SYN-RCVD状态，但都无法第三次握手（因为伪造ip不存在）

2）4次挥手中的FIN就相当于三次握手中的SYN。

3）序号seq，确认序号ack，确认标志位ACK作用还是一样的，就是确认作用（把seq加上1赋给ack，并把ACK置1）

4）为什么一个3次1个4次不一样？

因为两端的数据并不是同时发送完，所以两端谁发送完数据都需要自己告诉对方一次，并且对方确认一次。


